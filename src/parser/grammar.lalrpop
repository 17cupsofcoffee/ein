use ast::{Expr, Stmt, Operator};
use lexer::tokens::Token;

grammar<'input>;

pub Program: Vec<Stmt> = Block;

Block: Vec<Stmt> = "\n"? <a: (<Stmt> "\n")*> <b: Stmt> "\n"? => {
    let mut a = a;
    a.push(b);
    a
};

Stmt: Stmt = {
    "print" <Expr> => Stmt::Print(<>),
    "let" <id: "identifier"> "=" <e: Expr> => Stmt::Declaration(id.to_string(), e),
    Expr => Stmt::ExprStmt(<>),
};

Expr: Expr = ExprAssign;

ExprAssign: Expr = {
    <id: "identifier"> "=" <e: ExprAssign> => Expr::Assign(id.to_string(), Box::new(e)),
    ExprEq,
};

ExprEq: Expr = {
    <l: ExprEq> "!=" <r: ExprComp> => Expr::BinaryOp(Operator::NotEquals, Box::new(l), Box::new(r)),
    <l: ExprEq> "==" <r: ExprComp> => Expr::BinaryOp(Operator::Equals, Box::new(l), Box::new(r)),
    ExprComp,
};

ExprComp: Expr = {
    <l: ExprComp> ">"  <r: ExprAddSub> => Expr::BinaryOp(Operator::GreaterThan, Box::new(l), Box::new(r)),
    <l: ExprComp> ">=" <r: ExprAddSub> => Expr::BinaryOp(Operator::GreaterEquals, Box::new(l), Box::new(r)),
    <l: ExprComp> "<"  <r: ExprAddSub> => Expr::BinaryOp(Operator::LessThan, Box::new(l), Box::new(r)),
    <l: ExprComp> "<=" <r: ExprAddSub> => Expr::BinaryOp(Operator::LessEquals, Box::new(l), Box::new(r)),
    ExprAddSub,
};

ExprAddSub: Expr = {
    <l: ExprAddSub> "+" <r: ExprMulDiv> => Expr::BinaryOp(Operator::Add, Box::new(l), Box::new(r)),
    <l: ExprAddSub> "-" <r: ExprMulDiv> => Expr::BinaryOp(Operator::Subtract, Box::new(l), Box::new(r)),
    ExprMulDiv,
};

ExprMulDiv: Expr = {
    <l: ExprMulDiv> "*" <r: ExprUnary> => Expr::BinaryOp(Operator::Multiply, Box::new(l), Box::new(r)),
    <l: ExprMulDiv> "/" <r: ExprUnary> => Expr::BinaryOp(Operator::Divide, Box::new(l), Box::new(r)),
    ExprUnary,
};

ExprUnary: Expr = {
    "!" <ExprAtom> => Expr::UnaryOp(Operator::Not, Box::new(<>)),
    "-" <ExprAtom> => Expr::UnaryOp(Operator::UnaryMinus, Box::new(<>)),
    ExprAtom,
};

ExprAtom: Expr = {
    If,
    Literal,
    "(" <Expr> ")" => <>,
};

If: Expr = {
    "if" <c: Expr> "{" <t: Block> "}" => Expr::If(Box::new(c), t, vec![]),
    "if" <c: Expr> "{" <t: Block> "}" "else" "{" <f: Block> "}" => Expr::If(Box::new(c), t, f),
};

Literal: Expr = {
    "nil" => Expr::Nil,
    "true" => Expr::BooleanLiteral(true),
    "false" => Expr::BooleanLiteral(false),
    "number" => Expr::NumberLiteral(<>),
    "string" => Expr::StringLiteral(<>.to_string()),
    "identifier" => Expr::Identifier(<>.to_string()),
};

extern {
    type Location = usize;
    type Error = String;

    enum Token<'input> {
        // Sigils
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "," => Token::Comma,
        "." => Token::Dot,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "!" => Token::Not,
        "!=" => Token::NotEqual,
        "=" => Token::Equal,
        "==" => Token::EqualEqual,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        "\n" => Token::NewLine,

        // Literals
        "identifier" => Token::Identifier(<&'input str>),
        "string" => Token::String(<&'input str>),
        "number" => Token::Number(<f64>),

        // Keywords
        "and" => Token::And,
        "else" => Token::Else,
        "false" => Token::False,
        "fn" => Token::Fn,
        "for" => Token::For,
        "if" => Token::If,
        "nil" => Token::Nil,
        "or" => Token::Or,
        "print" => Token::Print,
        "return" => Token::Return,
        "this" => Token::This,
        "true" => Token::True,
        "let" => Token::Let,
        "while" => Token::While,
    }
}